"""Unit tests for the ExploitBuilder agent."""

import pytest
from pathlib import Path
from unittest.mock import AsyncMock, MagicMock, patch

from mrzero.agents.exploiter.agent import ExploitBuilderAgent
from mrzero.agents.base import AgentType
from mrzero.core.memory.state import AgentState
from mrzero.core.schemas import (
    ExecutionMode,
    Exploit,
    EnvironmentInfo,
    Vulnerability,
    VulnerabilityStatus,
    VulnerabilityType,
    VulnerabilitySeverity,
)


@pytest.fixture
def builder():
    """Create an ExploitBuilder agent instance."""
    return ExploitBuilderAgent()


@pytest.fixture
def sample_vulnerability():
    """Create a sample vulnerability for testing."""
    return Vulnerability(
        id="VULN-001",
        vuln_type=VulnerabilityType.SQL_INJECTION,
        severity=VulnerabilitySeverity.HIGH,
        score=85,
        status=VulnerabilityStatus.CONFIRMED,
        title="SQL Injection in login handler",
        description="Unsanitized user input in SQL query",
        file_path="app/routes/auth.py",
        line_number=42,
        code_snippet="query = f\"SELECT * FROM users WHERE username='{username}'\"",
        tool_source="hunter",
        confidence=0.9,
    )


@pytest.fixture
def sample_rce_vulnerability():
    """Create a sample RCE vulnerability for testing."""
    return Vulnerability(
        id="VULN-002",
        vuln_type=VulnerabilityType.RCE,
        severity=VulnerabilitySeverity.CRITICAL,
        score=95,
        status=VulnerabilityStatus.CONFIRMED,
        title="Remote Code Execution via command injection",
        description="User input passed directly to os.system()",
        file_path="app/utils/runner.py",
        line_number=15,
        code_snippet="os.system(f'echo {user_input}')",
        tool_source="hunter",
        confidence=0.95,
    )


@pytest.fixture
def sample_environment():
    """Create a sample environment info for testing."""
    return EnvironmentInfo(
        env_type="docker",
        build_successful=True,
        build_attempts=1,
        container_id="abc123",
        connection_port=8080,
        connection_ip="127.0.0.1",
    )


@pytest.fixture
def sample_state_with_vulns(tmp_path, sample_vulnerability):
    """Create a sample state with confirmed vulnerabilities."""
    target_dir = tmp_path / "target_project"
    target_dir.mkdir()

    # Create some files
    (target_dir / "app").mkdir()
    (target_dir / "app" / "routes").mkdir()
    (target_dir / "app" / "routes" / "auth.py").write_text("""
def login(username, password):
    query = f"SELECT * FROM users WHERE username='{username}'"
    return execute_query(query)
""")

    return AgentState(
        session_id="test-session",
        target_path=str(target_dir),
        mode=ExecutionMode.HITL,
        confirmed_vulnerabilities=[sample_vulnerability],
    )


@pytest.fixture
def sample_state_no_vulns(tmp_path):
    """Create a sample state without vulnerabilities."""
    target_dir = tmp_path / "target_project"
    target_dir.mkdir()

    return AgentState(
        session_id="test-session",
        target_path=str(target_dir),
        mode=ExecutionMode.HITL,
        confirmed_vulnerabilities=[],
    )


class TestExploitBuilderAgent:
    """Tests for the ExploitBuilder agent."""

    def test_agent_type(self, builder):
        """Test agent type is correct."""
        assert builder.agent_type == AgentType.EXPLOIT_BUILDER

    def test_system_prompt(self, builder):
        """Test system prompt contains key concepts."""
        prompt = builder.get_system_prompt()
        assert "MrZeroExploitBuilder" in prompt
        assert "exploit" in prompt.lower()
        assert "vulnerability" in prompt.lower()

    def test_system_prompt_mentions_tools(self, builder):
        """Test system prompt mentions available tools."""
        prompt = builder.get_system_prompt()
        prompt_lower = prompt.lower()
        # Should mention key tools
        assert "pwndbg" in prompt_lower
        assert "metasploit" in prompt_lower
        assert "ropgadget" in prompt_lower
        assert "frida" in prompt_lower
        assert "pwntools" in prompt_lower

    def test_system_prompt_mentions_exploitation_techniques(self, builder):
        """Test system prompt mentions exploitation techniques."""
        prompt = builder.get_system_prompt()
        prompt_lower = prompt.lower()
        # Should mention key techniques
        assert "sql injection" in prompt_lower
        assert "command injection" in prompt_lower
        assert "rop" in prompt_lower
        assert "buffer overflow" in prompt_lower

    def test_system_prompt_mentions_methods(self, builder):
        """Test system prompt references the new tool methods."""
        prompt = builder.get_system_prompt()
        # Should mention the methods agents can call
        assert "_run_pwndbg" in prompt
        assert "_run_metasploit" in prompt
        assert "_run_ropgadget" in prompt
        assert "_run_checksec" in prompt
        assert "_generate_payload" in prompt

    def test_detect_available_tools(self, builder):
        """Test tool detection works."""
        tools = builder._available_tools
        assert isinstance(tools, dict)
        # These should at least be checked
        assert "python3" in tools
        assert "pwntools" in tools
        assert "ropgadget" in tools
        assert "gdb" in tools

    def test_detect_available_tools_python3_available(self, builder):
        """Test python3 is detected as available."""
        # python3 should be available in test environment
        assert builder._available_tools["python3"] is True

    @pytest.mark.asyncio
    async def test_execute_no_vulnerabilities(self, builder, sample_state_no_vulns):
        """Test execution with no vulnerabilities returns early."""
        result = await builder.execute(sample_state_no_vulns)

        assert result.success is False
        assert "No confirmed vulnerabilities" in result.errors[0]
        assert result.output.get("exploits") == []
        assert result.next_agent == AgentType.REPORTER

    @pytest.mark.asyncio
    async def test_execute_returns_next_agent_reporter(self, builder, sample_state_with_vulns):
        """Test execution sets the next agent to Reporter."""
        with patch.object(builder, "chat", new_callable=AsyncMock) as mock_chat:
            # Mock the LLM responses
            mock_chat.return_value = """{
                "vulnerability_analysis": {"vuln_type": "sql_injection"},
                "exploitation_strategy": {"technique": "union-based", "goal": "data_exfiltration"},
                "tool_plan": [],
                "exploit_steps": [],
                "success_indicators": ["success"]
            }"""

            result = await builder.execute(sample_state_with_vulns)

            assert result.next_agent == AgentType.REPORTER

    def test_format_vulnerability_info(self, builder, sample_vulnerability, tmp_path):
        """Test vulnerability info formatting."""
        # Create the file for extended context
        (tmp_path / "app").mkdir()
        (tmp_path / "app" / "routes").mkdir()
        (tmp_path / "app" / "routes" / "auth.py").write_text("test code")

        info = builder._format_vulnerability_info(sample_vulnerability, tmp_path)

        assert sample_vulnerability.title in info
        assert sample_vulnerability.id in info
        assert "sql_injection" in info.lower()
        assert "high" in info.lower()  # severity is lowercase in output

    def test_format_environment_info_with_env(self, builder, sample_environment):
        """Test environment info formatting with environment."""
        info = builder._format_environment_info(sample_environment)

        assert "docker" in info.lower()
        assert "Successful" in info
        assert "8080" in info

    def test_format_environment_info_none(self, builder):
        """Test environment info formatting without environment."""
        info = builder._format_environment_info(None)

        assert "No environment" in info
        assert "manual testing" in info.lower()

    def test_format_available_tools(self, builder):
        """Test available tools formatting."""
        formatted = builder._format_available_tools()

        assert "Available Tools" in formatted
        assert "python3" in formatted.lower()

    def test_get_extended_code_context(self, builder, sample_vulnerability, tmp_path):
        """Test getting extended code context."""
        # Create file
        (tmp_path / "app").mkdir()
        (tmp_path / "app" / "routes").mkdir()
        file_path = tmp_path / "app" / "routes" / "auth.py"
        file_path.write_text("\n".join([f"line {i}" for i in range(100)]))

        context = builder._get_extended_code_context(
            tmp_path, sample_vulnerability, context_lines=10
        )

        assert ">>>" in context  # Should mark the vulnerable line
        assert "line" in context

    def test_get_extended_code_context_file_not_found(
        self, builder, sample_vulnerability, tmp_path
    ):
        """Test code context when file doesn't exist."""
        context = builder._get_extended_code_context(tmp_path, sample_vulnerability)

        assert "not found" in context.lower()

    def test_parse_llm_json_response_valid(self, builder):
        """Test parsing valid JSON response."""
        response = '```json\n{"key": "value"}\n```'
        result = builder._parse_llm_json_response(response)

        assert result == {"key": "value"}

    def test_parse_llm_json_response_raw_json(self, builder):
        """Test parsing raw JSON without code blocks."""
        response = 'Some text {"key": "value"} more text'
        result = builder._parse_llm_json_response(response)

        assert result == {"key": "value"}

    def test_parse_llm_json_response_invalid(self, builder):
        """Test parsing invalid JSON returns None."""
        response = "This is not JSON"
        result = builder._parse_llm_json_response(response)

        assert result is None

    def test_analyze_exploit_failure_with_results(self, builder):
        """Test exploit failure analysis with results."""
        test_results = {
            "error": "Segmentation fault",
            "output": "AAAA....",
            "return_code": -11,
            "timeout": False,
        }

        analysis = builder._analyze_exploit_failure(test_results)

        assert "Segmentation fault" in analysis
        assert "Return Code" in analysis

    def test_analyze_exploit_failure_timeout(self, builder):
        """Test exploit failure analysis with timeout."""
        test_results = {
            "timeout": True,
        }

        analysis = builder._analyze_exploit_failure(test_results)

        assert "Timeout" in analysis

    def test_analyze_exploit_failure_none(self, builder):
        """Test exploit failure analysis with no results."""
        analysis = builder._analyze_exploit_failure(None)

        assert "No test results" in analysis

    def test_create_exploit_object(self, builder, sample_vulnerability):
        """Test creating exploit object from data."""
        exploit_data = {
            "exploit_code": {
                "language": "python",
                "filename": "exploit.py",
                "code": "print('pwned')",
            },
            "exploitation_strategy": {
                "technique": "union-based",
                "goal": "data_exfiltration",
            },
            "payload_details": {
                "explanation": "Uses UNION to extract data",
            },
            "usage_instructions": {
                "execution": "python exploit.py",
            },
        }

        exploit = builder._create_exploit_object(
            vulnerability=sample_vulnerability,
            exploit_data=exploit_data,
            tested=True,
            successful=True,
            test_output="Data extracted successfully",
        )

        assert exploit.vulnerability_id == sample_vulnerability.id
        assert exploit.language == "python"
        assert exploit.code == "print('pwned')"
        assert exploit.tested is True
        assert exploit.successful is True

    def test_create_exploit_object_rce(self, builder, sample_rce_vulnerability):
        """Test creating exploit object for RCE."""
        exploit_data = {
            "exploit_code": {
                "language": "python",
                "filename": "rce_exploit.py",
                "code": "import socket; # reverse shell",
            },
            "exploitation_strategy": {
                "technique": "command injection",
                "goal": "code_execution",
            },
        }

        exploit = builder._create_exploit_object(
            vulnerability=sample_rce_vulnerability,
            exploit_data=exploit_data,
            tested=False,
            successful=False,
            test_output="",
        )

        assert exploit.vulnerability_id == sample_rce_vulnerability.id
        assert exploit.exploit_type == "rce"


class TestExploitBuilderToolMethods:
    """Tests for ExploitBuilder tool execution methods."""

    @pytest.fixture
    def builder(self):
        """Create builder with mocked tools."""
        return ExploitBuilderAgent()

    @pytest.mark.asyncio
    async def test_run_command_success(self, builder):
        """Test running a command successfully."""
        result = await builder._run_command("echo test", timeout=10)

        assert result["success"] is True
        assert "test" in result["output"]
        assert result["timeout"] is False

    @pytest.mark.asyncio
    async def test_run_command_failure(self, builder):
        """Test running a failing command."""
        result = await builder._run_command("exit 1", timeout=10)

        assert result["success"] is False
        assert result["returncode"] == 1

    @pytest.mark.asyncio
    async def test_run_command_timeout(self, builder):
        """Test command timeout handling."""
        result = await builder._run_command("sleep 10", timeout=1)

        assert result["success"] is False
        assert result["timeout"] is True

    @pytest.mark.asyncio
    async def test_run_ropgadget_not_installed(self, builder):
        """Test ROPgadget when not installed."""
        builder._available_tools["ropgadget"] = False

        result = await builder._run_ropgadget("/path/to/binary")

        assert result["success"] is False
        assert "not installed" in result["error"]

    @pytest.mark.asyncio
    async def test_run_checksec_with_pwntools(self, builder, tmp_path):
        """Test checksec fallback to pwntools when binary doesn't exist."""
        builder._available_tools["checksec"] = False
        builder._available_tools["pwntools"] = False

        result = await builder._run_checksec(str(tmp_path / "nonexistent"))

        assert result["success"] is False

    @pytest.mark.asyncio
    async def test_generate_payload_not_installed(self, builder):
        """Test payload generation when msfvenom not installed."""
        with patch("shutil.which", return_value=None):
            result = await builder._generate_payload(
                "shell_reverse_tcp",
                lhost="10.10.10.10",
                lport=4444,
            )

        assert result["success"] is False
        assert "not installed" in result["error"]

    def test_parse_checksec_output(self, builder):
        """Test parsing checksec output."""
        output = """
        RELRO:     Full RELRO
        Stack:     Canary found
        NX:        NX enabled
        PIE:       PIE enabled
        """

        protections = builder._parse_checksec_output(output)

        assert protections["RELRO"] == "Full"
        assert protections["Stack Canary"] is True
        assert protections["NX"] is True
        assert protections["PIE"] is True

    def test_get_tool_summary(self, builder):
        """Test tool summary generation."""
        summary = builder.get_tool_summary()

        assert "Available" in summary
        assert isinstance(summary, str)


class TestExploitBuilderToolsService:
    """Tests for ExploitBuilder ToolsService integration."""

    @pytest.fixture
    def builder(self):
        """Create builder instance."""
        return ExploitBuilderAgent()

    @pytest.mark.asyncio
    async def test_get_tools_service_lazy_loading(self, builder):
        """Test tools service is lazily loaded."""
        assert builder._tools_service is None
        assert builder._tools_service_initialized is False

        with patch(
            "mrzero.core.tools_service.get_initialized_tools_service",
            new_callable=AsyncMock,
        ) as mock_get:
            mock_service = MagicMock()
            mock_get.return_value = mock_service

            service = await builder._get_tools_service()

            assert service is mock_service
            assert builder._tools_service_initialized is True

    @pytest.mark.asyncio
    async def test_get_tools_service_cached(self, builder):
        """Test tools service is cached after first call."""
        mock_service = MagicMock()
        builder._tools_service = mock_service
        builder._tools_service_initialized = True

        service = await builder._get_tools_service()

        # Should return cached service without calling get_initialized_tools_service
        assert service is mock_service

    @pytest.mark.asyncio
    async def test_run_mcp_tool_pwndbg(self, builder):
        """Test MCP tool routing for pwndbg."""
        with patch.object(builder, "_get_tools_service", new_callable=AsyncMock) as mock_get:
            mock_service = MagicMock()
            mock_result = MagicMock()
            mock_result.success = True
            mock_result.output = "vmmap output"
            mock_result.error = None
            mock_result.execution_time = 0.5
            mock_service.run_debugger = AsyncMock(return_value=mock_result)
            mock_get.return_value = mock_service

            result = await builder._run_mcp_tool("pwndbg", "execute", command="vmmap")

            assert result["success"] is True
            assert result["output"] == "vmmap output"
            mock_service.run_debugger.assert_called_once()

    @pytest.mark.asyncio
    async def test_run_mcp_tool_metasploit(self, builder):
        """Test MCP tool routing for metasploit."""
        with patch.object(builder, "_get_tools_service", new_callable=AsyncMock) as mock_get:
            mock_service = MagicMock()
            mock_result = MagicMock()
            mock_result.success = True
            mock_result.output = "msf output"
            mock_result.error = None
            mock_result.execution_time = 1.0
            mock_service.run_exploitation = AsyncMock(return_value=mock_result)
            mock_get.return_value = mock_service

            result = await builder._run_mcp_tool("metasploit", "search", module="exploit/unix")

            assert result["success"] is True
            mock_service.run_exploitation.assert_called_once()

    @pytest.mark.asyncio
    async def test_run_pwndbg(self, builder):
        """Test pwndbg execution wrapper."""
        with patch.object(builder, "_run_mcp_tool", new_callable=AsyncMock) as mock_mcp:
            mock_mcp.return_value = {"success": True, "output": "heap info"}

            result = await builder._run_pwndbg("heap", target="/path/to/binary")

            assert result["success"] is True
            mock_mcp.assert_called_once_with(
                "pwndbg", "execute", command="heap", target="/path/to/binary"
            )

    @pytest.mark.asyncio
    async def test_run_metasploit(self, builder):
        """Test metasploit execution wrapper."""
        with patch.object(builder, "_run_mcp_tool", new_callable=AsyncMock) as mock_mcp:
            mock_mcp.return_value = {"success": True, "output": "module info"}

            result = await builder._run_metasploit(
                "use",
                module="exploit/unix/ftp/vsftpd_234_backdoor",
                options={"RHOSTS": "10.10.10.10"},
            )

            assert result["success"] is True
            mock_mcp.assert_called_once()

    @pytest.mark.asyncio
    async def test_run_ghidra(self, builder):
        """Test ghidra execution wrapper."""
        with patch.object(builder, "_run_mcp_tool", new_callable=AsyncMock) as mock_mcp:
            mock_mcp.return_value = {"success": True, "output": "decompiled code"}

            result = await builder._run_ghidra("decompile", "/path/to/binary", function="main")

            assert result["success"] is True
            mock_mcp.assert_called_once_with(
                "ghidra", "decompile", binary_path="/path/to/binary", function="main"
            )


class TestExploitBuilderLocalTools:
    """Tests for ExploitBuilder local tool methods."""

    @pytest.fixture
    def builder(self):
        """Create builder instance."""
        return ExploitBuilderAgent()

    @pytest.mark.asyncio
    async def test_run_frida_local_not_installed(self, builder):
        """Test frida local when not installed."""
        builder._available_tools["frida"] = False

        result = await builder._run_frida_local("target_app")

        assert result["success"] is False
        assert "not installed" in result["error"]

    @pytest.mark.asyncio
    async def test_run_pwntools_script_not_installed(self, builder):
        """Test pwntools script when not installed."""
        builder._available_tools["pwntools"] = False

        result = await builder._run_pwntools_script("from pwn import *")

        assert result["success"] is False
        assert "not installed" in result["error"]

    @pytest.mark.asyncio
    async def test_run_pwntools_script_execution(self, builder, tmp_path):
        """Test pwntools script execution."""
        builder._available_tools["pwntools"] = True

        with patch.object(builder, "_run_command", new_callable=AsyncMock) as mock_cmd:
            mock_cmd.return_value = {"success": True, "output": "0x414141414141"}

            result = await builder._run_pwntools_script("print(hex(0x414141414141))")

            assert mock_cmd.called


class TestExploitBuilderPrompts:
    """Tests for ExploitBuilder prompt templates."""

    @pytest.fixture
    def builder(self):
        """Create builder instance."""
        return ExploitBuilderAgent()

    def test_exploit_strategy_prompt_template(self, builder):
        """Test exploit strategy prompt has required placeholders."""
        prompt = builder.EXPLOIT_STRATEGY_PROMPT

        assert "{vulnerability_info}" in prompt
        assert "{environment_info}" in prompt
        assert "{available_tools}" in prompt
        assert "json" in prompt.lower()

    def test_exploit_generation_prompt_template(self, builder):
        """Test exploit generation prompt has required placeholders."""
        prompt = builder.EXPLOIT_GENERATION_PROMPT

        assert "{vulnerability_info}" in prompt
        assert "{strategy}" in prompt
        assert "{environment_info}" in prompt
        assert "{binary_analysis}" in prompt
        assert "json" in prompt.lower()

    def test_exploit_refinement_prompt_template(self, builder):
        """Test exploit refinement prompt has required placeholders."""
        prompt = builder.EXPLOIT_REFINEMENT_PROMPT

        assert "{original_exploit}" in prompt
        assert "{test_results}" in prompt
        assert "{error_analysis}" in prompt
        assert "json" in prompt.lower()


class TestExploitBuilderMaxAttempts:
    """Tests for ExploitBuilder iteration limits."""

    def test_max_exploit_attempts(self):
        """Test max exploit attempts constant."""
        builder = ExploitBuilderAgent()
        assert builder.MAX_EXPLOIT_ATTEMPTS == 5
